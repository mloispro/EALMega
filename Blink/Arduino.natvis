<?xml version="1.0" encoding="utf-8"?>

<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">

	<!-- gnu stl -->
	<Type Name="std::initializer_list&lt;*&gt;">
		<DisplayString>{{ size={_M_len} }}</DisplayString>
		<Expand>
			<ArrayItems>
				<Size>_M_len</Size>
				<ValuePointer>_M_array</ValuePointer>
			</ArrayItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::bitset&lt;*&gt;">
		<DisplayString>{{ size={$T1} }}</DisplayString>
		<Expand>
			<IndexListItems Condition="$T1&lt;=32">
				<Size>$T1</Size>
				<ValueNode>(_M_w &gt;&gt; $i) &amp; 1</ValueNode>
			</IndexListItems>
			<IndexListItems Condition="$T1&gt;32">
				<Size>$T1</Size>
				<ValueNode>(_M_w[$i / 32] &gt;&gt; ($i % 32)) &amp; 1</ValueNode>
			</IndexListItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::unique_ptr&lt;*&gt;">
		<DisplayString Condition="_M_t._M_head_impl == 0">empty</DisplayString>
		<DisplayString Condition="_M_t._M_head_impl != 0">unique_ptr {*_M_t._M_head_impl}</DisplayString>
		<Expand>
			<ExpandedItem Condition="_M_t._M_head_impl != 0">_M_t._M_head_impl</ExpandedItem>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::weak_ptr&lt;*&gt;">
		<DisplayString Condition="_M_ptr == 0">empty</DisplayString>
		<DisplayString Condition="_M_ptr != 0">weak_ptr {*_M_ptr}</DisplayString>
		<Expand>
			<ExpandedItem Condition="_M_ptr != 0">_M_ptr</ExpandedItem>
		</Expand>
	</Type>

	<Type Name="std::plus&lt;void&gt;">
		<DisplayString>plus&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::minus&lt;void&gt;">
		<DisplayString>minus&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::multiplies&lt;void&gt;">
		<DisplayString>multiplies&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::divides&lt;void&gt;">
		<DisplayString>divides&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::modulus&lt;void&gt;">
		<DisplayString>modulus&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::negate&lt;void&gt;">
		<DisplayString>negate&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::equal_to&lt;void&gt;">
		<DisplayString>equal_to&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::not_equal_to&lt;void&gt;">
		<DisplayString>not_equal_to&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::greater&lt;void&gt;">
		<DisplayString>greater&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::less&lt;void&gt;">
		<DisplayString>less&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::greater_equal&lt;void&gt;">
		<DisplayString>greater_equal&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::less_equal&lt;void&gt;">
		<DisplayString>less_equal&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::logical_and&lt;void&gt;">
		<DisplayString>logical_and&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::logical_or&lt;void&gt;">
		<DisplayString>logical_or&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::logical_not&lt;void&gt;">
		<DisplayString>logical_not&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::bit_and&lt;void&gt;">
		<DisplayString>bit_and&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::bit_or&lt;void&gt;">
		<DisplayString>bit_or&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::bit_xor&lt;void&gt;">
		<DisplayString>bit_xor&lt;&gt;</DisplayString>
		<Expand/>
	</Type>
	<Type Name="std::bit_not&lt;void&gt;">
		<DisplayString>bit_not&lt;&gt;</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::plus&lt;*&gt;">
		<DisplayString>plus</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::minus&lt;*&gt;">
		<DisplayString>minus</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::multiplies&lt;*&gt;">
		<DisplayString>multiplies</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::divides&lt;*&gt;">
		<DisplayString>divides</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::modulus&lt;*&gt;">
		<DisplayString>modulus</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::negate&lt;*&gt;">
		<DisplayString>negate</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::equal_to&lt;*&gt;">
		<DisplayString>equal_to</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::not_equal_to&lt;*&gt;">
		<DisplayString>not_equal_to</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::greater&lt;*&gt;">
		<DisplayString>greater</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::less&lt;*&gt;">
		<DisplayString>less</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::greater_equal&lt;*&gt;">
		<DisplayString>greater_equal</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::less_equal&lt;*&gt;">
		<DisplayString>less_equal</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::logical_and&lt;*&gt;">
		<DisplayString>logical_and</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::logical_or&lt;*&gt;">
		<DisplayString>logical_or</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::logical_not&lt;*&gt;">
		<DisplayString>logical_not</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::bit_and&lt;*&gt;">
		<DisplayString>bit_and</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::bit_or&lt;*&gt;">
		<DisplayString>bit_or</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::bit_xor&lt;*&gt;">
		<DisplayString>bit_xor</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::bit_not&lt;*&gt;">
		<DisplayString>bit_not</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::unary_negate&lt;*&gt;">
		<DisplayString>not1({_M_pred})</DisplayString>
		<Expand>
			<Item Name="[pred]">_M_pred</Item>
		</Expand>
	</Type>

	<Type Name="std::binary_negate&lt;*&gt;">
		<DisplayString>not2({_M_pred})</DisplayString>
		<Expand>
			<Item Name="[pred]">_M_pred</Item>
		</Expand>
	</Type>

	<Type Name="std::_Bind&lt;*&gt;">
		<DisplayString>bind({_M_f}, {_M_bound_args})</DisplayString>
		<Expand>
			<Item Name="[f]">_M_f</Item>
			<Item Name="[bound_args]">_M_bound_args</Item>
		</Expand>
	</Type>

	<Type Name="std::function&lt;*&gt;">
		<DisplayString Condition="_M_manager == 0">empty</DisplayString>
		<DisplayString Condition="_M_manager != 0">{*_M_manager}</DisplayString>
		<Expand>
			<ExpandedItem Condition="_M_manager != 0">*_M_manager</ExpandedItem>
		</Expand>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;1,1000000000&gt; &gt;">
		<DisplayString>{__r} nanoseconds</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;1,1000000&gt; &gt;">
		<DisplayString>{__r} microseconds</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;1,1000&gt; &gt;">
		<DisplayString>{__r} milliseconds</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;1,1&gt; &gt;">
		<DisplayString>{__r} seconds</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;60,1&gt; &gt;">
		<DisplayString>{__r} minutes</DisplayString>
		<Expand/>
	</Type>

	<Type Name="std::chrono::duration&lt;*,std::ratio&lt;3600,1&gt; &gt;">
		<DisplayString>{__r} hours</DisplayString>
		<Expand/>
	</Type>


	<!-- gnu stl -->
	<Type Name="std::vector&lt;*&gt;">
		<DisplayString>{{size={_M_impl._M_finish - _M_impl._M_start}}}</DisplayString>
		<Expand>
			<Item Name="[size]" ExcludeView="simple">_M_impl._M_finish - _M_impl._M_start</Item>
			<Item Name="[capacity]" ExcludeView="simple">_M_impl._M_end_of_storage - _M_impl._M_start</Item>
			<ArrayItems>
				<Size>_M_impl._M_finish - _M_impl._M_start</Size>
				<ValuePointer>_M_impl._M_start</ValuePointer>
			</ArrayItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::list&lt;*&gt;">
		<DisplayString Condition="_M_impl._M_node._M_next == &amp;_M_impl._M_node">empty</DisplayString>
		<Expand>
			<LinkedListItems Condition="_M_impl._M_node._M_next != &amp;_M_impl._M_node">
				<HeadPointer>(std::list&lt;$T1,$T2&gt;::_Node*)&amp;_M_impl._M_node</HeadPointer>
				<NextPointer>_M_next</NextPointer>
				<ValueNode>_M_data</ValueNode>
				<NoValueHeadPointer>true</NoValueHeadPointer>
			</LinkedListItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::pair&lt;*&gt;">
		<DisplayString>{{{first},{second}}}</DisplayString>
		<Expand>
			<Item Name="first">first</Item>
			<Item Name="second">second</Item>
		</Expand>
	</Type>


	<!-- gnu stl -->
	<Type Name="std::map&lt;*&gt;">
		<DisplayString>{{size={_M_t._M_impl._M_node_count}}}</DisplayString>
		<Expand>
			<Item Name="[size]">_M_t._M_impl._M_node_count</Item>
			<TreeItems>
				<Size>_M_t._M_impl._M_node_count</Size>
				<HeadPointer>(std::map&lt;$T1,$T2,$T3,$T4&gt;::_Rep_type::_Link_type)_M_t._M_impl._M_header._M_parent</HeadPointer>
				<LeftPointer>_M_left</LeftPointer>
				<RightPointer>_M_right</RightPointer>
				<ValueNode>_M_value_field</ValueNode>
			</TreeItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::set&lt;*&gt;">
		<DisplayString>{{size={_M_t._M_impl._M_node_count}}}</DisplayString>
		<Expand>
			<Item Name="[size]">_M_t._M_impl._M_node_count</Item>
			<TreeItems>
				<Size>_M_t._M_impl._M_node_count</Size>
				<HeadPointer>(std::set&lt;$T1,$T2,$T3&gt;::_Rep_type::_Link_type)_M_t._M_impl._M_header._M_parent</HeadPointer>
				<LeftPointer>_M_left</LeftPointer>
				<RightPointer>_M_right</RightPointer>
				<ValueNode>_M_value_field</ValueNode>
			</TreeItems>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::shared_ptr&lt;*&gt;">
		<DisplayString>shared_ptr {{{_M_ptr}}}</DisplayString>
		<Expand>
			<ExpandedItem>_M_ptr</ExpandedItem>
		</Expand>
	</Type>

	<!-- gnu stl -->
	<Type Name="std::string">
		<AlternativeType Name="std::basic_string&lt;char&gt;" />
		<DisplayString>{_M_dataplus._M_p}</DisplayString>
		<Expand>
			<Item Name="[string]" ExcludeView="simple">_M_dataplus._M_p</Item>
			<Item Name="[size]">((std::basic_string&lt;char&gt;::_Rep*)_M_dataplus._M_p)[-1]._M_length</Item>
			<Item Name="[capacity]">((std::basic_string&lt;char&gt;::_Rep*)_M_dataplus._M_p)[-1]._M_capacity</Item>
		</Expand>
	</Type>
	<Type Name="String">
		<DisplayString>{_M_dataplus._M_p}</DisplayString>
		<Expand>
			<Item Name="[string]" ExcludeView="simple">_M_dataplus._M_p</Item>
			<Item Name="[size]">((std::basic_string&lt;char&gt;::_Rep*)_M_dataplus._M_p)[-1]._M_length</Item>
			<Item Name="[capacity]">((std::basic_string&lt;char&gt;::_Rep*)_M_dataplus._M_p)[-1]._M_capacity</Item>
		</Expand>
	</Type>

	<Type Name="std::array&lt;*,*&gt;">
		<DisplayString>{{ size={$T2} }}</DisplayString>
		<Expand>
			<ExpandedItem>_M_elems</ExpandedItem>
		</Expand>
	</Type>

	<Type Name="std::deque&lt;*&gt;">
		<DisplayString>{{ size={(_M_impl._M_finish._M_node-_M_impl._M_start._M_node-1)*(512/(int)((($T1*)0)+1))+(_M_impl._M_finish._M_cur-_M_impl._M_finish._M_first)+(_M_impl._M_start._M_last-_M_impl._M_start._M_cur)} }}</DisplayString>
		<Expand>
			<IndexListItems>
				<Size>(_M_impl._M_finish._M_node-_M_impl._M_start._M_node-1)*(512/(int)((($T1*)0)+1))+(_M_impl._M_finish._M_cur-_M_impl._M_finish._M_first)+(_M_impl._M_start._M_last-_M_impl._M_start._M_cur)</Size>
				<ValueNode>_M_impl._M_map[(_M_impl._M_start._M_node-_M_impl._M_map) + $i / (512/(int)((($T1*)0)+1)) % _M_impl._M_map_size][((_M_impl._M_start._M_cur-_M_impl._M_start._M_first) +$i) % (512/(int)((($T1*)0)+1))]</ValueNode>
			</IndexListItems>
		</Expand>
	</Type>

	<Type Name="std::forward_list&lt;*&gt;">
		<DisplayString Condition="_M_impl._M_head._M_next == 0">empty</DisplayString>
		<DisplayString Condition="_M_impl._M_head._M_next != 0">non-empty</DisplayString>
		<Expand>
			<LinkedListItems>
				<HeadPointer>(std::forward_list&lt;$T1,$T2&gt;::_Node*)_M_impl._M_head._M_next</HeadPointer>
				<NextPointer>_M_next</NextPointer>
				<ValueNode>*($T1*)&amp;_M_storage</ValueNode>
			</LinkedListItems>
		</Expand>
	</Type>

	<Type Name="std::queue&lt;*&gt;">
		<AlternativeType Name="std::stack&lt;*&gt;" />
		<DisplayString>{c}</DisplayString>
		<Expand>
			<Item Name="c">c</Item>
		</Expand>
	</Type>

	<Type Name="std::priority_queue&lt;*&gt;">
		<DisplayString>{c}</DisplayString>
		<Expand>
			<Item Name="c [heap]">c</Item>
			<Item Name="comp">comp</Item>
		</Expand>
	</Type>

	<Type Name="std::complex&lt;*&gt;">
		<DisplayString>{_M_value}</DisplayString>
	</Type>

	<Type Name="std::valarray&lt;*&gt;">
		<DisplayString>{{ size={_M_size} }}</DisplayString>
		<Expand>
			<ArrayItems>
				<Size>_M_size</Size>
				<ValuePointer>_M_data</ValuePointer>
			</ArrayItems>
		</Expand>
	</Type>

	<!-- llvm stl -->
	<Type Name="std::__1::vector&lt;*&gt;">
		<DisplayString>{{size={__end_ - __begin_}}}</DisplayString>
		<Expand>
			<Item Name="[size]" ExcludeView="simple">__end_ - __begin_</Item>
			<Item Name="[capacity]" ExcludeView="simple">__end_cap_.__first_ - __begin_</Item>
			<Item Name="[allocator]" ExcludeView="simple">__end_cap_</Item>
			<ArrayItems>
				<Size>__end_ - __begin_</Size>
				<ValuePointer>__begin_</ValuePointer>
			</ArrayItems>
		</Expand>
	</Type>

	<!-- llvm stl -->
	<Type Name="std::__1::map&lt;*&gt;">
		<DisplayString>{{size={__tree_.__pair3_.__first_}}}</DisplayString>
		<Expand>
			<Item Name="[size]">__tree_.__pair3_.__first_</Item>
			<TreeItems>
				<Size>__tree_.__pair3_.__first_</Size>
				<HeadPointer>(std::__1::map&lt;$T1,$T2,$T3,$T4&gt;::__base::__node_pointer)__tree_.__pair1_.__first_-&gt;__left_</HeadPointer>
				<LeftPointer>__left_</LeftPointer>
				<RightPointer>__right_</RightPointer>
				<ValueNode>__value_</ValueNode>
			</TreeItems>
		</Expand>
	</Type>

	<!-- llvm stl -->
	<Type Name="std::__1::shared_ptr&lt;*&gt;">
		<DisplayString>shared_ptr {{{__ptr_}}}</DisplayString>
		<Expand>
			<Item Condition="__ptr_ != 0" Name="[ptr]">($T1*)__ptr_</Item>
			<Item Condition="__cntrl_ != 0" Name="[control block]">*__cntrl_</Item>
		</Expand>
	</Type>



</AutoVisualizer>
